《ZooKeeper：分布式过程协同技术详解》读书笔记
=

zk的主要宗旨
-
**在分布式系统中协作多个任务**


zk的使用实例
-
   + HBase : 用于选主,保存集群元数据
   + Kafka : 检测崩溃,主题(topic)发现
   + solr  : 存储集群元数据,并协作更新这些元素

zk客户端的功能
-
   + 保障强一致性,有序性和持久性
   + 实现通用的同步原语的能力




zk提供的API方法
-
    create /path data
    delete /path
    exists /path
    setData /path data
    getData /path
    getChildren /path

 >**注意zk不允许局部写入或者局部读取节点数据**

znode节点类型
-
   + 持久节点
   + 临时节点
   + 持久有序
   + 临时无序


节点监视
-
   >监视点是**`单次`**触发的操作
   
   >**客户端在重新设置监听节点前需要读取节点状态**
   
   >**通知机制的一个重要保障 : 对同一个节点的操作,先通知客户端传送通知,再对该节点进行变更**
   
   
zk仲裁
-

> **zk使用法定人数来解决延迟问题,指为了使zk工作必须有效运行的服务器的最小数量**
> **zk的会话提供了顺序保障,意味着同一个会话中的请求会以FIFO(先进先出)顺序执行**

zk会话
-
>假设会话超时时间为t

>在**`服务端`**侧,经过时间t之后,若接收不到这个会话的任何信息,服务就回声明会话过期

>在**`客户端`**侧,如果经过t/3时间未收到任何消息,客户端将向服务器发送心跳消息.在经过2t/3的时间后,zk客户端开始寻找其他的服务器,而此时它还有t/3的时间去查找

>当zk尝试重新到一个不同的服务器时,需连接到一个状态比自己观察到更新的服务器

>zk客户端会监控与与服务之间的链接,客户端库不仅告诉我们链接发生问题,还会主动尝试建立通信.所以请不要关闭会话后再启动一个新的会话,这样会增加系统负载,并导致更长时间的中断


监视点
-
>一个监视点表示一个与之关联的znode节点和事件类型组成的**`单次`**触发器.当应用程序注册了一个监视点来接收通知,匹配该监视点条件的**`第一个`**事件会触发监视点的通知,并且**`最多只触发一次`**.

>客户端的`监视点与会话关联`,如果会话过期,等待中的监视点会被删除.不过监视点可以跨越不同服务端的连接而保持.例如当zk客户端与集群中某一个zk服务端断开连接后,重新连接到集群的另一个zk服务端,客户端会先发送监视点列表,
 ,在注册监视点列表时,新服务端会检查监视点列表中的znode节点在重连之间的时间是否有发生变化,如果有发生变化,一个监视点的时间就会发送给客户端,否则在新的服务端上注册监视点.
 
>zk的API中所有读操作 : getData , getChildren 和 exists 方法均可以选择在读取znode节点时设置监视点.使用监视节点机制时,我们需要实现Watcher接口,实现process()方法
 
>WatchedEvent数据结构包括以下信息

        会话状态 : Disconnected,SyncConnected,AuthFailed,ConnectedReadOnly,SaslAuthenticated,Expired
        事件类型 : NodeCreated, NodeDeleted ,NodeDataChanged ,NodeChildrenChange ,None
        路径(如果事件类型不是None时)
        
        
>zk服务器集群使用内部协议来保持客户端之间状态的同步,对客户端呈现一致性视图        


故障
-
>当一个进程失去连接后就无法收到zk的更新通知,这些通知很可能就包括了重要的状态变化通知,比如错过了另一个进程选主的通知.

>监视点与Disconnected事件
>>exists操作比较特殊,即使zk客户端会在新的zk服务器建立新的监视点,但依旧存在错过监视点的情况.



注意事项
-
ACL内置的鉴权模式

    + OPEN_ACL_UNSAFE(相当于无权限,任何人zk客户端都可以访问)
    + super模式 (相当于超级管理员权限)
    + digest模式(设置权限类型)
    + ip鉴权模式(基于IP地址的权限,但不能鉴别伪造的IP地址)
    
顺序保障性

    zk无法保障连接丢失的操作顺序性


同步方法阻塞问题
    
    同步的zk调用会阻塞运行,直到收到响应信息,如果多个线程同时向zk提交了同步操作,这些线程将阻塞直到收到响应消息,
    zk会顺序返回响应信息,但操作结果可能因线程调度的原因导致后提交的操作而先被执行

    
zk内部原理
-
>zk集群有三种服务器角色
+ leader
+ follower
+ observer(为了系统的扩展性)

>zk集群会有群首(leader),其它机器为追随者(follower).leader作为中心点处理所有对zk系统变更的请求,建立了所有对zk状态的更新的顺序,follower
接收群首所发出更新操作请求,并对这些请求进行处理,以此来保障状态更新操作不会发生碰撞.

>请求

    zk服务器会在本地处理只读请求(exists,getData和getChildren).
    会改变集群状态的写请求(create,delete和setData)将会被转发给群首,群首执行相应的请求,并形成状态的更新,称之为事务.
    请求表示源自于客户端发起的操作,而事务则包含了对应请求处理而改变zk状态所需要的执行的步骤.
    一个事务为一个单位,也就是说所有的变更处理需要以原子方式执行.
    当群首产生一个事务,就会为该事务分配一个标识符,称之为zk会话ID(zxid),通过zxid对事务进行标识,就可以按照群首所指定的顺序在各个服务器中按序执行
    
    
    
>zk选主原理

    一个服务器必须被仲裁的法定数量的服务器所认可才能成为群首
     服务器之间互相发送投票信息,vote(serverId,zxid)
     当服务器接收到投票信息时,按照以下规则修改投票信息,
      if (otherZxid > myZxid || (otherZxid == myZxid && otherServerId > myServerId )
          保留当前选票
      else
          修改自己的投票, vote(otherServerId,otherZxid)
      
     总结,拥有最新的zxid的服务器会成为群首,如果多个服务器拥有相同的zxid,那么serverId最大的那个会成为群首
          
          


>zab 状态更新的广播协议


    zk集群使用zab协议解决如何确认一个事务是否提交的问题,通过该协议提交一个事务非常简单,类似于一个两阶段提交
    1.群首向所有追随者发送一个PROPOSAL(提案)消息
    2.当一个追随者接收到消息后,会响应一个ACK信息,通知群首其已经接受提案
    3.当收到仲裁数量的服务器发送的确认消息后(仲裁数包括群首自己),群首就会发送消息通知追随者进行提交操作
    
    
>zab协议重要属性
+ 如果群首按顺序广播了事务T和事务T',那么每个服务器在提交T'事务前保证事务T已经提交完成
+ 如果某个服务器按照事务T,事务T'顺序提交事务,所有其其它服务器也必然会在提交事务T'前提交事务T
    

    
>观察者
    
    观察者不参与投票,zk引入观察者的主要目的是提高读请求的可扩展性.
    写操作的吞吐率取决于仲裁数量的大小.如果我们加入更多的追随者,将需要更大的仲裁数量,而这将减少写操作的吞吐率.
    新加一个观察者的开销 : 对应于每一个已提交事务点引入一条额外消息.这个开销相对于增加参与投票的服务器来说小很多.
    配置zk集群的观察者 : 
        1.配置文件中添加以下行 : peerType = observer
        2.server.x        [hostname]: m : n  [:observer] 的配置需加上observer
    
>独立服务器
    
    zk中最简单的流水线是独立服务器(ZeeKeeperServer类),它包含三种请求处理器 :
        PreRequestProcess (A) -> SyncRequestProcess(B) -> FinalRequestProcess(C)
     
     - A接受客户端的请求并执行这个请求,处理结果是生成一个事务.事务时执行一个操作的结果,该操作会反映到zk的数据树上.
     - B负责将事务持久化到磁盘上,实际上就是将事务追加到事务日志中,并生成快照数据.
     - C如果A中包含事务数据,则对zk数据树修改,否则读取数据树返回给客户端
         

         
配置
-

>zk集群中使用**tickTime**作为超时时间单位.客户端最小会话超时时间为两个tick时间.

    tickTime默认为3000ms,更低的tickTime值可以更快地发现超时问题,但也会导致更高的网络流量(心跳信息)和更高的CPU使用率(会话存储器的处理)
    minSessionTimeout(最小会话时间)默认为tickTime的两倍.配置该值过低可能会导致错误的客户端故障检测,配置该参数值过高会延迟客户端故障的检测时间
    maxSessionTimeout(最大会话超时时间),可以限制一个客户端消耗系统资源的时间,默认情况下maxSessionTimeout的时间为tickTime的20倍.
    
    客户端实际获得的超时时间不会低于minSessionTimeout也不会高于maxSessionTimeout
    
  
>集群配置
+ initLimit      追随者最初连接到群首时得超时值,单位为tick的整数倍(配置该值需参考群首与追随者之间的网络差顺服速度情况,传输数据量的大小)
+ syncLimit      追随者与群首进行sync操作时得超时值,单位为tick值得倍数(该值依赖于网络的延迟和吞吐量)
+ leaderServer   指示群首服务器是否为客户端提供服务.默认值为yes
+ server.x        [hostname]: m : n  [:observer] . m代表事务发送的端口,n代表群首选举的端口,observer标志这台服务器是否是观察者


>zk集群的重配置

    重配置可以让维护人员不需要手工进行重配置操作而导致状态信息的破坏,而且不需要停止任何服务
    使用动态配置之前zk集群的配置文件 :
        tickTime=2000
        initLimit=10
        syncLimit=4
        dataDir=./data
        dataLogDir=./txnlog
        clientPort=2182
        server.1=127.0.0.1:2222:2223
        server.2=127.0.0.1:3333:3334
        server.3=127.0.0.1:4444:4445
        
     使用动态配置的zk集群配置方式 : 
         tickTime=2000
         initLimit=10
         syncLimit=4
         dataDir=./data
         dataLogDir=./txnlog
         dynamicConfigFile=./dyn.cfg   //指定动态文件的位置
            
          dync.dfg服务器配置形式如下 : 
            server.id = host : m : n[:role];[client_address]client_port
            
             因此dyn.cfg动态文件如下 :
              server.1=127.0.0.1:2222:2223:participant;2181
              server.2=127.0.0.1:3333:3334:participant;2182
              server.3=127.0.0.1:4444:4445:participant;2183
     
     
    注意客户端连接的服务端口号配置已经移到动态文件配置!
    当动态配置文件准备就绪时,就可以使用reconfig操作来重新配置一个集群,该操作可以增量或全量地进行更新操作.
       增量方式 : 
           reconfig -remove 2,3 -add \
               server.4=127.0.0.1:5555:5556:participant;2184
               server.5=127.0.0.1:4444:4445:participant;2185
        全量方式 :
           reconfig -file newconf     
    
    
    
    
  
               
            
  
    
    